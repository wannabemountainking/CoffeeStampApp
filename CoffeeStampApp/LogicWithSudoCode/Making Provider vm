
1단계: .xcdatamodeld 파일 생성
 - xcode에서 BookDB라는 이름으로 model db 생성하고
 - Entity는 Book으로 추가하고 속성으로 title: String, author: String, publishedYear: Int16, isRead: Bool = false 설정을 하고
 - 이 NSManagedObject를 커스터마이징 하기 위해 codegen은 class Definition -> Manually로 한다.
 - Book.swift를 만들고 final class 로 만들고 NSManagedObject를 상속한다
    - 각 속성은 Book 의 Entity속성과 동일하게 만들되 @NSManaged 를 붙여서 만든다( 이것은 아직 이해가 안됨 )
    - 이 Book 타입은 실질적으로 Core Data에 저장하는 것으로 여기에 isValid 라는 boolean 값을 계산속성으로 만들어서 title이나 author가 없으면 false 모두 있으면 true로 만들어 쓸데없이 인스턴스가 만들어지는 것을 방지한다.
    - 타입 메서드로 all()을 만들어서 FetchRequest로 request를 스스로 만들어 내도록 한다.(한번 호출하면 전역에서 사용할 수 있게되는 Stamp 타입의 구축) 이때 request에 정렬 순서도 결정한다.
    - 추가로 empty 타입 메서드도 만들어서 빈 껍질의 Stamp도 Core Data에 저장할 수 있는 형태로 만든다.(왜 그렇게 만드는 지 모르겠음)
 
2단계: Provider 클래스 작성
 - BookProvider.swift  를 만들어 Core Data를 관리한다
 - container는 init에서 entityName 으로 만들어 주고 -> 여기서는 "Book"
 - context는 그 container의 viewContext(이미 제공되는?)를 계산속성으로 얻는다
 - 실제 사용할 newContext도 만드는데 이는 viewContext가 singleton 방식이어서 그냥 사용할 경우 코드가 꼬일 수 있어 실제 사용할 newContext를 사용하는 것이다.
 - newContext는 계산속성으로 우선 NSManagedObjectContext타입으로 생성하고 인자로 mainThread에서 사용되는 것을 지정한 후, 그 값은 어떻게 처리하더라... 모르겠다.
 - init(): 초기화는 container를 초기화하고 context를 Core Data에서 로드하여 성공하면 성공메시지, 실패하면 실패메시지를 보낸다.
 - 추가로 exist 메서드도 만들어서 context 안에 Book 타입이 있으면 그 값을 리턴하고 그렇지 않으면 nil을 리턴한다.
 
 3단계: ViewModel만들기
  - BookViewModel.swift 파일을 생성한다. 여기서는 book과 isNew를 @Publihsed 속성으로 해서 Core Data와 Context를 통해서 소통하도록 하는 CRUD 메서드 로직을 구현한다.
  - 속성으로 privider는 주입받고, context는 초기화 코드에서 newContext로 갈아끼워 초기화 한다.
  - 초기화 단계에서 성격이 비슷한 create와 edit를 구별하기 위해서 book의 nil여부에 따라서 있으면 edit가 가능하도록 exist메서드로 book 값을 가져오고 없으면 새로 만들기 위해 일반적 book빈 것을 생성한다. 그리고 이에 따라 isNew도 true, false를 결정한다.
  
4단계: BookListView 만들기
 - BookListView.swift를 만든다.
 - provider는 singleton 패턴으로 받고 코어 데이터의 Book 타입들은 books 환경변수에 담아 두루두루 쓰일 수 있게 하며 viewModel은 역시 환경변수로Vm으로 받는다.
 - 상태변수로 stampToEdit: Book? 는 수정할 파일을 담고 클릭으로 선택한 내용은 상태 변수인 selectedItem: Book?으로 받는다.
 - NavigationStack, List , ForEach등을 이용하여 UI를 구현한다.
 
